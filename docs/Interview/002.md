---
title: 简历梳理-DMP项目
titleTemplate: 面试复盘
outline: "deep"
---

# DMP 项目

## 项目概述

### 项目目标

DMP 项目是数据库智能运维管理平台。通过自动化部署、智能诊断等功能提高数据库运维的效率和稳定性。在这个项目里，前端通过提供可视化界面，让运维人员和业务部门能够方便地查看和管理数据库。

### 实现的部分功能

1. 用户权限管理：根据不同角色（运维人员、业务人员等）进行平台权限划分，确保数据安全和操作权限的合理分配。
2. 主机管理：对数据库所在主机进行管理，依据产品 license 授权提供高可用组件、监控组件等业务组件的安装。
3. 数据库自动化部署和运维：用户通过功能按钮，填写必要信息即可完成自动化部署和日常运维
4. 前端监控界面：展示主机和数据库的状态等信息，帮助运维人员监控系统运行情况

## 技术栈/工具

- react:用于构建 UI，采用组件化开发模式
- react-router:实现页面路由管理
- redux/react-redux:用于全局状态管理，通过 store 管理应用的状态，并通过 actions 和 reducers 更新状态
- @reduxjs/toolkit:简化 Redux 的使用
- ant design: UI 组件库
- antv G2/G6: 用于 DashBoard 页面各种类型的图表绘制
- axios:和后端 API 进行数据交互
- vite:用于项目构建
- ESLint 和 Prettier:保证团队代码风格统一
- TypeScript：提供静态类型检查

## 项目架构

### 项目开发流程

1. 产品经理在需求交付会给出原型设计，前端、后端、测试都需要参加会议
2. 需求确定无误后，前后端沟通接口设计,并创建对应的 jira 任务，用于任务进度追踪，如果中途有需求变更，也需要在 jira 中创建新的任务并确认产品 已经更新 confluence 上的原型文档。
3. 开发期间，测试会根据产品原型出测试用例文档用于各方评审，确认和需求一致
4. 开发完成后根据这个文档进行初步测试，无明显缺陷后提交给测试
5. 提交测试后，需要及时跟进测试在 jira 上发布的缺陷

项目开发分为 2 类，缺陷修复和新需求开发，缺陷修复的优先级高于新需求开发

### 前端代码质量管理

1. 代码规范：通过 eslint,stylelint 等工具确保代码符合规范
2. 代码复审：每次提交到 gitlab 上的 MR 都需要经过团队成员 code review 后才可以将这个 MR 合并到主分支
3. 注释：对于当前没有更好解决方案的代码，需要详细注释，方便后续维护修复
4. 自动化检查：每次提交 MR 的时候，gitlab 会先自动执行 lint 检查

## 前端安全

客户会出安全检测报告，我们会根据报告解决潜在的风险。比如修改平台配置参数的时候，textarea 会需要用户输入一些信息，如果用户输入一段 js 代码，这段代码可以执行，这就是 XSS(跨站脚本攻击)，前端的解决方案包括：

1. 尽量避免使用`dangerouslySetInnerHTML`
2. 前端对用户提交的数据进行校验，确保符合预期格式
3. 对特殊字符进行转义，比如`<`转换为`&lt`

## 项目挑战与解决方案【亮点】

### 登录接口多次报错后禁止登录

#### 背景

登录 DMP 时多次登录错误后需要等待一定时间才能再次登录，提示需要等待 xx 秒后才能再次登录

前端任务：在页面根据接口返回的等待时间，显示一个倒计时，同时期间禁止使用登录按钮，

#### 难点

很容易想到用 setTimeout 定时器可以实现，但 JavaScript 是单线程语言，当停留在倒计时所在的浏览器标签页，倒计时可以准确展示，但当开了一个新的标签页，js 需要优先处理新标签页的任务，这意味着原来倒计时任务优先级会降低，即可能出现两三秒才执行一次倒计时，导致倒计时的时间不准确。

#### 解决方案

已知倒计时的时间和当前计算机的时间，可以计算得到倒计时截止的时间，离开页面的计时无法控制，但重新回到页面之后可以根据这个时间修正倒计时时间，从而保证倒计时的准确性

```js
const getSecondTime = (seconds) => {
  return Math.floor(new Date().getTime() / 1000) + seconds;
};
const handleCountDown = (endTime) => {
  //获取当前的时间戳
  const currentTime = getSecondTime(0);
  // 计算剩余时间并展示
  document.getElementById("timer_num").innerText = endTime - currentTime;
  const countDownTimer = setTimeout(() => {
    clearTimeout(countDownTimer);
    if (currentTime < endTime) {
      handleCountDown(endTime);
    } else {
      document.getElementById("timer_num").innerText = 0;
    }
  }, 1000);
};
const totalTime = getSecondTime(30);
handleCountDown(totalTime);
```

#### 效果和影响

即使用户离开当前浏览器标签页，回来时也可以正确展示倒计时

### 性能优化【还需优化】

#### 背景

DMP 项目使用的构建工具是 webpack，随着项目越来越大，冷启动时间也越来越长，需要 3 分钟才能启动，热更新也需要 10s 左右。

#### 难点

项目规模大如何能快速启动项目和热更新，提高开发效率

#### 解决方案

构建工具从 webpack 替换为 vite

原理：

1. Webpack 在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而 Vite 则采用了基于 ES Module 的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。
2. Webpack 在打包时，会把所有的模块打包成一个 bundle，这会导致初次加载速度较慢；而 Vite 则利用了浏览器对 ES Module 的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。
3. Webpack 的配置相对复杂，对新手不够友好；而 Vite 在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。
4. Webpack 的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite 的热更新则只会针对改动的模块进行更新，提高了更新速度

#### 效果和影响

项目冷启动时间从 3 分钟变为 1 秒多，热更新时间从 10s 变为几乎感知不到

### 外库项目在 DMP 项目中的展示[还需优化]

#### 背景

DMP 随着集成的数据库类型越来越多，导致项目庞大且难以维护，各个数据库的新需求开发和缺陷修复都要依赖于 DMP 本体的版本发布，无法独立发版。为了减少耦合度，需要将各个数据库的前端页面从 DMP 中逐步拆分为单个项目。

#### 难点

1. 如何在 DMP 上展示扩展库相关的页面
2. DMP 项目和单独的数据库项目如何通信

#### 解决方案

#### 效果和影响
